(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{175:function(t,n,e){"use strict";e.r(n);var r=e(0),a=Object(r.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{staticClass:"content"},[t._m(0),t._v(" "),e("p",[e("a",{attrs:{href:"https://www.angular.cn/guide/lifecycle-hooks",target:"_blank",rel:"noopener noreferrer"}},[t._v("官方文档：https://www.angular.cn/guide/lifecycle-hooks"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("生命周期函数通俗的讲就是组件创建、组件更新、组件销毁的时候会触发的一系列的方法。")]),t._v(" "),e("p",[t._v("当 Angular 使用构造函数新建一个组件或指令后，就会按下面的顺序在特定时刻调用这些 生命周期钩子方法。\nconstructor 构造函数中除了使用简单的值对局部变量进行初始化 之外，什么都不应该做。 （非生命周期函数）")]),t._v(" "),t._m(1),t._v(" "),e("p",[t._v("当 Angular（重新）设置数据绑定输入属性时响应。 该 方法接受当前和上一属性值的 SimpleChanges 对象 当被绑定的输入属性的值发生变化时调用，首次调用一 定会发生在 ngOnInit() 之前。")]),t._v(" "),t._m(2),t._v(" "),e("p",[t._v("在 Angular 第一次显示数据绑定和设置指令/组件的输 入属性之后，初始化指令/组件。 在第一轮 ngOnChanges() 完成之后调用，只调用一次。 使用 ngOnInit() 有两个原因：")]),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),e("p",[t._v("并在发生 Angular 无法或不愿意自己检测的变 化时作出反应。在每个 Angular 变更检测周期中调用， ngOnChanges() 和 ngOnInit() 之后。")]),t._v(" "),t._m(5),t._v(" "),e("p",[t._v("当把内容投影进组件之后调用。第一次 ngDoCheck() 之 后调用，只调用一次。")]),t._v(" "),t._m(6),t._v(" "),e("p",[t._v("每次完成被投影组件内容的变更检测之后调用。 ngAfterContentInit() 和每次 ngDoCheck() 之后调用。 ngAfterViewInit() 初 始 化 完 组 件 视 图 及 其 子 视 图 之 后 调 用 。 第 一 次 ngAfterContentChecked() 之后调用，只调用一次。")]),t._v(" "),t._m(7),t._v(" "),e("p",[t._v("每次做完组件视图和子视图的变更检测之后调用。 ngAfterViewInit()和每次 ngAfterContentChecked() 之后 调用。")]),t._v(" "),t._m(8),t._v(" "),e("p",[t._v("当 Angular 每次销毁指令/组件之前调用并清扫。在这 儿反订阅可观察对象和分离事件处理器，以防内存泄 漏。在 Angular 销毁指令/组件之前调用")])])}),[function(){var t=this.$createElement,n=this._self._c||t;return n("h2",{attrs:{id:"一、-angular-中的生命周期函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一、-angular-中的生命周期函数"}},[this._v("#")]),this._v(" 一、 Angular 中的生命周期函数")])},function(){var t=this.$createElement,n=this._self._c||t;return n("h3",{attrs:{id:"ngonchanges"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ngonchanges"}},[this._v("#")]),this._v(" ngOnChanges()")])},function(){var t=this.$createElement,n=this._self._c||t;return n("h3",{attrs:{id:"ngoninit"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ngoninit"}},[this._v("#")]),this._v(" ngOnInit()")])},function(){var t=this.$createElement,n=this._self._c||t;return n("ul",[n("li",[this._v("1、在构造函数之后马上执行复杂的初始化逻辑")]),this._v(" "),n("li",[this._v("2、在 Angular 设置完输入属性之后，对该组件进行准备。有经验的开发者会认同组件的构建应该很便宜和安全。")])])},function(){var t=this.$createElement,n=this._self._c||t;return n("h3",{attrs:{id:"ngdocheck-检测，"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ngdocheck-检测，"}},[this._v("#")]),this._v(" ngDoCheck() 检测，")])},function(){var t=this.$createElement,n=this._self._c||t;return n("h3",{attrs:{id:"ngaftercontentinit"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ngaftercontentinit"}},[this._v("#")]),this._v(" ngAfterContentInit()")])},function(){var t=this.$createElement,n=this._self._c||t;return n("h3",{attrs:{id:"ngaftercontentchecked"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ngaftercontentchecked"}},[this._v("#")]),this._v(" ngAfterContentChecked()")])},function(){var t=this.$createElement,n=this._self._c||t;return n("h3",{attrs:{id:"ngafterviewchecked"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ngafterviewchecked"}},[this._v("#")]),this._v(" ngAfterViewChecked()")])},function(){var t=this.$createElement,n=this._self._c||t;return n("h3",{attrs:{id:"ngondestroy"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ngondestroy"}},[this._v("#")]),this._v(" ngOnDestroy()")])}],!1,null,null,null);n.default=a.exports}}]);