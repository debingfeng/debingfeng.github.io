(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{228:function(a,t,s){"use strict";s.r(t);var v=s(0),_=Object(v.a)({},(function(){var a=this.$createElement;this._self._c;return this._m(0)}),[function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("div",{staticClass:"content"},[s("h1",{attrs:{id:"h5性能优化实践"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#h5性能优化实践"}},[a._v("#")]),a._v(" H5性能优化实践")]),a._v(" "),s("h2",{attrs:{id:"h5性能优化意义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#h5性能优化意义"}},[a._v("#")]),a._v(" H5性能优化意义")]),a._v(" "),s("p",[a._v("对于一个H5的产品，功能无疑很重要，但是性能同样是用户体验中不可或缺的一环。原本H5的渲染性能就不及native的app，如果不把性能优化做起来，将极大地影响用户使用产品的积极性。")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("用户感受")]),a._v(" "),s("p",[a._v("当用户能够在1-2秒内打开H5页面，看到信息的展示，或者能够开始进行下一步的操作，用户会感觉速度还好，可以接受；而页面如果在2-5秒后才进入可用的状态，用户的耐心会逐渐丧失；而如果一个界面超过5秒甚至更久才能显示出来，这对用户来说基本是无法忍受的，也许有一部分用户会退出重新进入，但更多的用户会直接放弃使用。")])])]),a._v(" "),s("h2",{attrs:{id:"优化方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优化方案"}},[a._v("#")]),a._v(" 优化方案")]),a._v(" "),s("p",[s("strong",[a._v("特别注意：Loading进度条")])]),a._v(" "),s("p",[a._v("在加载时间较长的时候，务必要让用户明确感知到加载完成的提示，通常是在加载过程中显示Loading的进度条，加载完成的时候隐藏它。从心理上，这会让用户有一种“期盼感”，而不至于太过枯燥。")]),a._v(" "),s("h3",{attrs:{id:"首屏加载"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#首屏加载"}},[a._v("#")]),a._v(" 首屏加载")]),a._v(" "),s("p",[a._v("用户从点击按钮开始载入网页，在他的感知中，什么时候是“加载完成”？是首屏加载，即在可见的屏幕范围内，内容展现完全，loading进度条消失。因此在H5性能优化中，一个很重要的目的就是尽可能提升这个“首屏加载”的时间，让它满足“一秒钟法则”。")]),a._v(" "),s("h3",{attrs:{id:"按需加载"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#按需加载"}},[a._v("#")]),a._v(" 按需加载")]),a._v(" "),s("p",[a._v("首先要明确，按需加载虽然能提升首屏加载的速度，但是可能带来更多的界面重绘，影响渲染性能，因此要评估具体的业务场景再做决定。")]),a._v(" "),s("h3",{attrs:{id:"延迟加载或者懒加载"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#延迟加载或者懒加载"}},[a._v("#")]),a._v(" 延迟加载或者懒加载")]),a._v(" "),s("p",[a._v("延迟加载或者懒加载\n这并不是一个新的技术，在PC时代也是非常常用的一种性能优化手段。这个方案的原则是让屏幕外，或者不影响整体效果显示的图片、背景等资源，在界面就绪之后再进行网络加载。")]),a._v(" "),s("h3",{attrs:{id:"滚屏加载"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#滚屏加载"}},[a._v("#")]),a._v(" 滚屏加载")]),a._v(" "),s("p",[a._v("滚屏加载是一种常见的无刷新动态加载数据的方案，通常用在列表形式数据展示中。一方面，数据不是通过翻页进行加载，这样就避免了再一次请求和渲染整个页面；另一方面，数据显示的数量是受限的，例如第一次只请求了10条数据，也就只需要渲染这10条数据，下拉滚屏的时候，再去获得下面10条数据。")]),a._v(" "),s("h3",{attrs:{id:"media-query（响应式加载）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#media-query（响应式加载）"}},[a._v("#")]),a._v(" Media Query（响应式加载）")]),a._v(" "),s("p",[a._v("响应式设计是现在网站设计的一个流行趋势，随着移动互联网的发展，这项技术也越来越受到重视。通过这项技术，我们能够方便地控制资源的加载与显示，例如说在分辨率不同的手机上，分别使用不同的css，加载不同大小的图片资源。 方案参考：http://www.poluoluo.com/jzxy/201206/167034.html")]),a._v(" "),s("h3",{attrs:{id:"第三方资源异步加载"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第三方资源异步加载"}},[a._v("#")]),a._v(" 第三方资源异步加载")]),a._v(" "),s("p",[a._v("第三方资源有的时候不可控，比如说页面统计、地图显示、分享组件等，这些第三方资源使用的时候要慎重选择，充分考察它们对于性能的影响，使用异步加载的方式进行，防止第三方资源的使用影响到页面本身的功能。")]),a._v(" "),s("h3",{attrs:{id:"favicon-ico"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#favicon-ico"}},[a._v("#")]),a._v(" Favicon.ico")]),a._v(" "),s("p",[a._v("如果我们没有设置图标ico，则会加载默认的图标：域名目录下的favicon.ico。很多开发者没有注意到这一点，就会导致这个请求404或者500。")]),a._v(" "),s("p",[a._v("通常，我们在应用内部打开网页，不会显示这个图标出来（除非放到浏览器中显示网页），我们需要保证这个图标存在，尽可能地小（一般4KB以下），并且设置一个较长的缓存过期时间。")]),a._v(" "),s("h3",{attrs:{id:"图片的使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#图片的使用"}},[a._v("#")]),a._v(" 图片的使用")]),a._v(" "),s("p",[a._v("格式选择")]),a._v(" "),s("p",[a._v("显示效果较好的图片格式中，有webp、jpg和png24/32这几种常见的图片格式。一般来说，webp的图片最小，但在iOS或者android4.0以下的系统中可能会有兼容性问题需要解决。")]),a._v(" "),s("p",[a._v("Jpg是我们最常使用的方案，大小适中，解码速度快，兼容性问题也基本不存在，是我们在H5的应用中使用起来性价比最高的方案。")]),a._v(" "),s("p",[a._v("Png24或png32，一般来说，显示效果肯定会比jpg更好，但是实际上人眼很难感知出来，所以在H5应用中要避免这种格式的大图片。")]),a._v(" "),s("p",[a._v("对于少量的图片，推荐用智图或者tinypng等工具来帮助自己选择合适的大小、格式。")]),a._v(" "),s("p",[a._v("像素控制")]),a._v(" "),s("p",[a._v("在H5应用中，图片的像素要严格控制，一般来说不建议宽度超过640px。")]),a._v(" "),s("h3",{attrs:{id:"小图片合并"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#小图片合并"}},[a._v("#")]),a._v(" 小图片合并")]),a._v(" "),s("p",[a._v("在html网页中，如果有多个小图片需要加载，不妨试试CSS Sprites方案，尤其是一些基本不变，大小差不多的操作类型图标。")]),a._v(" "),s("h3",{attrs:{id:"避免html代码中的大小重设"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#避免html代码中的大小重设"}},[a._v("#")]),a._v(" 避免html代码中的大小重设")]),a._v(" "),s("p",[a._v("在html或者css中，如果有类似width: **px这样的代码，就要注意看一看了，如果说图片显示的效果是宽度100px，而下载的图片却是200px宽度，那这大小基本上就是所需要的4倍面积了，所以在H5应用中，使用图片的一个原则就是需要显示成多大，就下载多大的资源。")]),a._v(" "),s("h3",{attrs:{id:"避免dataurl"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#避免dataurl"}},[a._v("#")]),a._v(" 避免DataURL")]),a._v(" "),s("p",[a._v("DataURL是用Base64的方式，将图片变成一串文本编码放入代码的方式。这种方式有好处，因为它可以减少一次http交互的请求，对于一些体积特别小的图片，或者是动态生成的图片可以考虑使用。但在H5应用中，一般情况下，我们都是需要避免DataURL的，因为它的数据体积通常比二进制图片的格式大1/3，而且它不会被浏览器缓存，每次页面刷新都需要重新加载这部分数据。")]),a._v(" "),s("h3",{attrs:{id:"使用图片的替代-css3-svg-iconfont"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用图片的替代-css3-svg-iconfont"}},[a._v("#")]),a._v(" 使用图片的替代(css3, svg, iconfont)")]),a._v(" "),s("p",[a._v("CSS3和svg可以更好地使用GPU进行渲染加速，而且会避免增加图片资源导致的http请求增加。例如一些div的圆角效果，就完全可以用用css来实现。")]),a._v(" "),s("p",[a._v("Iconfont，可以认为是一种矢量类型的操作字体。如果页面中有较多的操作图标，可以考虑使用iconfont来替代图片资源。")])])}],!1,null,null,null);t.default=_.exports}}]);