(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{261:function(e,t,r){"use strict";r.r(t);var s=r(0),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("div",{staticClass:"content"},[e._m(0),e._v(" "),r("p"),e._m(1),r("p"),e._v(" "),e._m(2),e._v(" "),r("h2",{attrs:{id:"vue组件的生命周期示例图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue组件的生命周期示例图"}},[e._v("#")]),e._v(" "),r("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue组件的生命周期示例图"),r("OutboundLink")],1)]),e._v(" "),e._m(3),e._v(" "),e._m(4),e._v(" "),r("p",[e._v("1、在公共Js中根据生产环境、测试环境和开发环境域名不同来定义不同的域名")]),e._v(" "),e._m(5),r("p",[e._v("2、在构建的时候根据node环境变量来判断来构建打包")]),e._v(" "),r("p",[e._v("示例参考\n"),r("a",{attrs:{href:"https://www.webpackjs.com/guides/production/#%E9%85%8D%E7%BD%AE",target:"_blank",rel:"noopener noreferrer"}},[e._v("webpack生产环境官方配置说明"),r("OutboundLink")],1)]),e._v(" "),e._m(6),e._v(" "),r("p",[e._v("http://deploy.test/front/static/css/static/fonts/ionicons.24712f6.ttf")]),e._v(" "),r("p",[e._v("http://deploy.test/front/static/fonts/ionicons.24712f6.ttf")]),e._v(" "),r("p",[e._v("在 webpack 出现之前，前端开发人员会使用 grunt 和 gulp 等工具来处理资源，并将它们从 /src 文件夹移动到 /dist 或 /build 目录中。同样方式也被用于 JavaScript 模块，但是，像 webpack 这样的工具，将动态打包(dynamically bundle)所有依赖项（创建所谓的依赖图(dependency graph)）。这是极好的创举，因为现在每个模块都可以_明确表述它自身的依赖，我们将避免打包未使用的模块。")]),e._v(" "),r("p",[e._v("webpack 最出色的功能之一就是，除了 JavaScript，还可以通过 loader 引入任何其他类型的文件。也就是说，以上列出的那些 JavaScript 的优点（例如显式依赖），同样可以用来构建网站或 web 应用程序中的所有非 JavaScript 内容。让我们从 CSS 开始起步，或许你可能已经熟悉了这个设置过程。")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://www.webpackjs.com/guides/asset-management/#loading-css",target:"_blank",rel:"noopener noreferrer"}},[e._v("示例说明参考官方配置"),r("OutboundLink")],1)]),e._v(" "),e._m(7),e._v(" "),e._m(8),e._v(" "),e._m(9),e._v(" "),r("ul",[r("li",[e._v("计算属性缓存与方法")]),e._v(" "),r("li",[e._v("计算属性与侦听器")]),e._v(" "),r("li",[r("a",{attrs:{href:"https://juejin.im/post/5b98c4da6fb9a05d353c5fd7",target:"_blank",rel:"noopener noreferrer"}},[e._v("计算属性的基本实现原理"),r("OutboundLink")],1)])]),e._v(" "),e._m(10),e._v(" "),e._m(11),e._v(" "),r("p",[r("a",{attrs:{href:"https://vuex.vuejs.org/zh/guide/",target:"_blank",rel:"noopener noreferrer"}},[e._v("vuex官方网站"),r("OutboundLink")],1)]),e._v(" "),r("p",[e._v("状态管理的问题")]),e._v(" "),e._m(12),e._v(" "),r("p",[e._v("子路由、嵌套路由")]),e._v(" "),e._m(13),e._v(" "),e._m(14),e._v(" "),e._m(15),e._v(" "),r("p",[r("a",{attrs:{href:"https://www.kancloud.cn/yunye/axios/234845",target:"_blank",rel:"noopener noreferrer"}},[e._v("详细查看中文文档"),r("OutboundLink")],1)]),e._v(" "),e._m(16),e._v(" "),e._m(17),e._m(18),e._v(" "),e._m(19),e._v(" "),e._m(20),e._m(21),e._v(" "),e._m(22),e._m(23),e._v(" "),e._m(24),e._m(25),e._v(" "),r("p",[r("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Flex参考文档"),r("OutboundLink")],1)]),e._v(" "),e._m(26),e._v(" "),e._m(27),e._v(" "),e._m(28),e._m(29),e._v(" "),r("p",[e._v("Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。")]),e._v(" "),e._m(30),e._m(31),e._v(" "),r("p",[e._v("Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。\n另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。")]),e._v(" "),e._m(32),e._m(33),e._v(" "),r("p",[e._v("用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。")]),e._v(" "),e._m(34),e._v(" "),r("p",[e._v("Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。")]),e._v(" "),e._m(35),e._v(" "),e._m(36),e._v(" "),r("p",[e._v("Promise 必须为以下三种状态之一：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。一旦Promise被resolve或reject，不能再迁移至其他任何状态（即状态 immutable）。\n为保持代码清晰，暂无异常处理。同时为表述方便，约定如下：")]),e._v(" "),r("p",[e._v("fulfilled 使用 resolved 代替\nonFulfilled 使用 onResolved 代替")]),e._v(" "),e._m(37),e._v(" "),r("p",[e._v("从构造函数开始，我们一步步实现符合 Promsie A+ 规范的 Promise。大概描述下，Promise构造函数需要做什么事情。")]),e._v(" "),e._m(38),e._v(" "),e._m(39),r("p",[e._v("_state 和 _value 变量很容易理解，_deferreds变量做什么？规范描述：then 方法可以被同一个 promise 调用多次。为满足多次调用 then 注册回调处理，内部选择使用 _deferreds 数组存储处理对象。具体处理对象结构，见 then 函数章节。\n最后执行 fn 函数，并调用 promise 内部的私有方法 resolve 和 reject。resolve 和 reject 内部细节随后介绍。")]),e._v(" "),e._m(40),e._v(" "),r("p",[e._v("Promise A+提到规范专注于提供通用的 then 方法。then 方法可以被同一个 promise 调用多次，每次返回新 promise 对象 。then 方法接受两个参数onResolved、onRejected（可选）。在 promise 被 resolve 或 reject 后，所有 onResolved 或 onRejected 函数须按照其注册顺序依次回调，且调用次数不超过一次。\n根据上述，then 函数执行流程大致为：")]),e._v(" "),r("p",[e._v("实例化空 promise 对象用来返回（保持then链式调用）\n构造 then(..) 注册回调处理函数结构体\n判断当前 promise 状态，pending 状态存储延迟处理对象 deferred ，非pending状态执行 onResolved 或 onRejected 回调\n...")]),e._v(" "),e._m(41),r("p",[e._v("Handler 函数封装存储 onResolved、onRejected 函数和新生成 promise 对象。")]),e._v(" "),e._m(42),e._m(43),e._v(" "),e._m(44),r("p",[e._v("复制代码假如 then 函数执行返回 this 调用对象本身，那么 promise2 === promise1，promise2 状态也应该等于 promise1 同为 resolved。而 onResolved 回调中返回状态为 rejected 对象。考虑到 Promise 状态一旦 resolved 或 rejected就不能再迁移，所以这里 promise2 也没办法转为回调函数返回的 rejected 状态，产生矛盾。\nhandleResolved 函数功能为根据当前 promise 状态，异步执行 onResolved 或 onRejected 回调函数。因在 resolve 或 reject 函数内部同样需要相关功能，提取为单独模块。往下翻阅查看。")]),e._v(" "),r("p",[r("a",{attrs:{href:"http://es6.ruanyifeng.com/#docs/promise",target:"_blank",rel:"noopener noreferrer"}},[e._v("ECMAScript 6 - 阮一峰"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://promisesaplus.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Promises/A+ 规范"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://juejin.im/post/5a30193051882503dc53af3c",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考文章掘金上的文章"),r("OutboundLink")],1)])])}),[function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"发布平台开发中vue相关问题积累与解决"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发布平台开发中vue相关问题积累与解决"}},[this._v("#")]),this._v(" 发布平台开发中Vue相关问题积累与解决")])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("div",{staticClass:"table-of-contents"},[r("ul",[r("li",[r("a",{attrs:{href:"#vue的底层原理实现"}},[e._v("Vue的底层原理实现")])]),r("li",[r("a",{attrs:{href:"#vue组件的生命周期示例图-https-cn-vuejs-org-v2-guide-instance-html-e7-94-9f-e5-91-bd-e5-91-a8-e6-9c-9f-e5-9b-be-e7-a4-ba"}},[e._v("Vue组件的生命周期示例图")])]),r("li",[r("a",{attrs:{href:"#打包构建资源引用问题"}},[e._v("打包构建资源引用问题")]),r("ul",[r("li",[r("a",{attrs:{href:"#根据环境变量的不同构建不同环境的代码"}},[e._v("根据环境变量的不同构建不同环境的代码")])]),r("li",[r("a",{attrs:{href:"#css引用字体路径不正确的问题"}},[e._v("CSS引用字体路径不正确的问题")])])])]),r("li",[r("a",{attrs:{href:"#计算属性"}},[e._v("计算属性")])]),r("li",[r("a",{attrs:{href:"#vue中的render渲染函数"}},[e._v("vue中的render渲染函数")])]),r("li",[r("a",{attrs:{href:"#vuex全局状态管理的问题"}},[e._v("vuex全局状态管理的问题")])]),r("li",[r("a",{attrs:{href:"#路由设置"}},[e._v("路由设置")]),r("ul",[r("li",[r("a",{attrs:{href:"#路有监听"}},[e._v("路有监听")])]),r("li",[r("a",{attrs:{href:"#路由设置的问题"}},[e._v("路由设置的问题")])])])]),r("li",[r("a",{attrs:{href:"#axios设置问题"}},[e._v("axios设置问题")])]),r("li",[r("a",{attrs:{href:"#布局flex"}},[e._v("布局Flex")])]),r("li",[r("a",{attrs:{href:"#promise异步返回问题"}},[e._v("promise异步返回问题")]),r("ul",[r("li",[r("a",{attrs:{href:"#promise基本使用"}},[e._v("promise基本使用")])]),r("li",[r("a",{attrs:{href:"#promise实现原理"}},[e._v("Promise实现原理")])])])])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"vue的底层原理实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue的底层原理实现"}},[this._v("#")]),this._v(" Vue的底层原理实现")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"打包构建资源引用问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#打包构建资源引用问题"}},[this._v("#")]),this._v(" 打包构建资源引用问题")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"根据环境变量的不同构建不同环境的代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#根据环境变量的不同构建不同环境的代码"}},[this._v("#")]),this._v(" 根据环境变量的不同构建不同环境的代码")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('// 示例\nconst production = host.indexOf("static.watch.okii.com") > -1;\n\n// 定位接口域名\nexport const location_domain = production\n    ? `${protocol}//location.watch.okii.com`\n    : `${protocol}//location.module.okii.com`;\n    \n')])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"css引用字体路径不正确的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#css引用字体路径不正确的问题"}},[this._v("#")]),this._v(" CSS引用字体路径不正确的问题")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"计算属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#计算属性"}},[this._v("#")]),this._v(" 计算属性")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("计算属性的初衷")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("blockquote",[t("p",[this._v("设计的初衷是用于简单运算的，避免在模板中有太多的计算。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"vue中的render渲染函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue中的render渲染函数"}},[this._v("#")]),this._v(" vue中的render渲染函数")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"vuex全局状态管理的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vuex全局状态管理的问题"}},[this._v("#")]),this._v(" vuex全局状态管理的问题")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"路由设置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#路由设置"}},[this._v("#")]),this._v(" 路由设置")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"路有监听"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#路有监听"}},[this._v("#")]),this._v(" 路有监听")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"路由设置的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#路由设置的问题"}},[this._v("#")]),this._v(" 路由设置的问题")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"axios设置问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#axios设置问题"}},[this._v("#")]),this._v(" axios设置问题")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("全局设置")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("axios.defaults.baseURL = 'https://api.example.com';\naxios.defaults.headers.common['Authorization'] = AUTH_TOKEN;\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("拦截器")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("blockquote",[t("p",[this._v("在请求或响应被 then 或 catch 处理前拦截它们。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("// 添加请求拦截器\naxios.interceptors.request.use(function (config) {\n    // 在发送请求之前做些什么\n    return config;\n  }, function (error) {\n    // 对请求错误做些什么\n    return Promise.reject(error);\n  });\n\n// 添加响应拦截器\naxios.interceptors.response.use(function (response) {\n    // 对响应数据做点什么\n    return response;\n  }, function (error) {\n    // 对响应错误做点什么\n    return Promise.reject(error);\n  });\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("blockquote",[t("p",[this._v("如果你想在稍后移除拦截器，可以这样：")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("var myInterceptor = axios.interceptors.request.use(function () {/*...*/});\naxios.interceptors.request.eject(myInterceptor);\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("blockquote",[t("p",[this._v("可以使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("axios.get('/user/12345', {\n  validateStatus: function (status) {\n    return status < 500; // 状态码在大于或等于500时才会 reject\n  }\n})\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"布局flex"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#布局flex"}},[this._v("#")]),this._v(" 布局Flex")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"promise异步返回问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise异步返回问题"}},[this._v("#")]),this._v(" promise异步返回问题")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"promise基本使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise基本使用"}},[this._v("#")]),this._v(" promise基本使用")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("const promise = new Promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("介绍一下Then方法")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v('getJSON("/posts.json").then(function(json) {\n  return json.post;\n}).then(function(post) {\n  // ...\n});\n')])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("catch方法")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("p.then((val) => console.log('fulfilled:', val))\n  .catch((err) => console.log('rejected', err));\n\n// 等同于\np.then((val) => console.log('fulfilled:', val))\n  .then(null, (err) => console.log(\"rejected:\", err));\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("finally方法")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("Promise.all()")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"promise实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise实现原理"}},[this._v("#")]),this._v(" Promise实现原理")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("Promise 状态")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("Promise 构造函数")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("初始化 Promise 状态（pending）")]),this._v(" "),t("li",[this._v("初始化 then(..) 注册回调处理数组（then 方法可被同一个 promise 调用多次）")]),this._v(" "),t("li",[this._v("立即执行传入的 fn 函数，传入Promise 内部 resolve、reject 函数")]),this._v(" "),t("li",[this._v("...")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("function Promise (fn) {\n  // 省略非 new 实例化方式处理\n  // 省略 fn 非函数异常处理\n\n  // promise 状态变量\n  // 0 - pending\n  // 1 - resolved\n  // 2 - rejected\n  this._state = 0;\n  // promise 执行结果\n  this._value = null;\n \n  // then(..) 注册回调处理数组\n  this._deferreds = [];\n\n  // 立即执行 fn 函数\n  try {\n    fn(value => {\n      resolve(this, value);\n    },reason => {\n      reject(this, reason);\n    })\n  } catch (err) {\n    // 处理执行 fn 异常\n    reject(this, err);\n  }\n}\n\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("then 函数")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("Promise.prototype.then = function (onResolved, onRejected) {\n\n  var res = new Promise(function () {});\n  // 使用 onResolved，onRejected 实例化处理对象 Handler\n  var deferred = new Handler(onResolved, onRejected, res);\n\n  // 当前状态为 pendding，存储延迟处理对象\n  if (this._state === 0) {\n    this._deferreds.push(deferred);\n    return res;\n  }\n\n  // 当前 promise 状态不为 pending\n  // 调用 handleResolved 执行onResolved或onRejected回调\n  handleResolved(this, deferred);\n  \n  // 返回新 promise 对象，维持链式调用\n  return res;\n};\n\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("function Handler (onResolved, onRejected, promise) {\n  this.onResolved = typeof onResolved === 'function' ? onResolved : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("链式调用为什么要返回新的 promise\n如我们理解，为保证 then 函数链式调用，then 需要返回 promise 实例。但为什么返回新的 promise，而不直接返回 this 当前对象呢？看下面示例代码：")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("var promise2 = promise1.then(function (value) {\n  return Promise.reject(3)\n})\n")])])])}],!1,null,null,null);t.default=n.exports}}]);